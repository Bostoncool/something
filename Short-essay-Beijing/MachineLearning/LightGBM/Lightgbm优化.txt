下面将**逐图分析你遇到的问题**，包括：

1. **为什么训练图中同一个 X 值对应多个 Y 值？**
2. **为什么折线图会出现“打结”“来回跳动”的现象？**
3. **逐个解释所有图的含义**
4. **结合代码给出优化建议**

---

# ✅ 一、为什么同一个 X 轴值有多组 Y？

### ✔ 原因：X 轴不是“唯一值”，而是“真实 PM2.5 值 / 预测 PM2.5 值”，它们存在大量重复

例如：

* 实际 PM2.5 = 35 µg/m³ 在 10 年数据中出现了 200 次
* 模型分别给出了 200 个预测值 → 所以 X=35 对应多个 Y

在散点图中：

```
X = y_true
Y = y_pred
```

这本质上是**实际值 - 预测值的散点关系图**，由于实际值重复，因此多个点会落在同一个 X 值上 → 形成“竖条状的多点堆叠”。

➡ 这不是 bug，是所有回归模型的正常现象。

---

# ✅ 二、为什么折线图会出现“打结”？（Time series 预测图）

在时间序列预测图中：

```
axes[0].plot(time_idx, y_test.iloc[plot_idx], 'k-')
axes[0].plot(time_idx, y_test_pred_basic[plot_idx], 'b--')
```

### ✔ 打结原因之一：真实值和预测值变化剧烈

PM2.5 本身就是波动极大的数据（突然暴增/暴跌）。

当两条线差异较大、又快速变化时，折线图就会出现：

* 锯齿
* 频繁交叉（看起来像打结）
* 分布很散

---

### ✔ 打结原因之二：你使用 **datetime 作为 X 轴，但日期之间不是“规则间隔”**

`time_idx` 是从 y_test 的 index 截取的：

如果数据里某些天缺失或被 dropna 去掉，时间轴就不连续。
Matplotlib 连接不连续日期时会产生**

* 线段跨越跳跃
* 看起来像线条乱跑/打结

---

### ✔ 打结原因之三（很关键）：预测线不够平滑

LightGBM 属于树模型 → 预测本身就是 piece-wise constant 分段函数，会更“跳”。

---

# ✅ 三、逐图解释含义（非常详细）

以下所有截图，你全部已经正确生成，我按图内容总结含义。

---

## ① Prediction Error Distribution（误差分布）

### 看什么？

* 误差是否居中于 0
* 是否呈高斯分布
* 宽度代表误差大小

### 你这里看到什么？

* 基础模型 Std ≈ 15.29
* 优化模型 Std ≈ 14.95 → **更稳定**
* Mean 都为负 ≈ -4 → **模型系统性低估 PM2.5**

---

## ② Feature Importance（特征重要性）

Gain 和 Split：

* **Gain：每个特征带来的损失下降量（更可靠）**
* **Split：分裂次数（粗略）**

你看到：

* PM2.5_ma3、PM2.5_ma7、PM2.5_lag1 强势 → **模型高度依赖历史值**
* 气象变量如 blh / sp / d2m 重要性一般 → 正常（气象对 PM2.5 是辅助因素）

---

## ③ Model Comparison（R²、RMSE、MAE、MAPE 比较）

结论：

* 提升不大（R² 0.60 → 0.612）
* RMSE 从 15.79 → 15.47

➡ **改进幅度很小** → 表明特征空间与模型复杂度还有瓶颈。

---

## ④ Training Curves（训练曲线）

训练集 vs 验证集：

* 训练误差持续下降
* 验证误差在某点稳定 → early stopping 生效

优化模型训练更久（best iteration=240 vs 207）

---

## ⑤ Time Series Prediction（300 天序列对比）

* 真实值波动大
* 模型无法完全跟上 → 线条交叉 → “打结”
* 优化模型更贴近真实值但仍偏低估峰值

---

## ⑥ Prediction Scatter（真实 vs 预测散点）

特点：

* 大部分点聚集在低浓度区（正常）
* 浓度越高，预测误差越大 → 树模型千真万确的弱点

---

## ⑦ Residuals Analysis（残差 vs 预测）

* 残差不完全随机 → 有一些结构性的模式
* 大值预测偏差更大 → 模型 underfit 高浓度段

---

# ✅ 四、关键问题 + 原因总结（最重要部分）

## 🔥 1. 为什么 X 对应多个 Y？

因为散点图里：

```
X = actual PM2.5（或 predicted PM2.5）
Y = predicted（或 residuals）
```

同一天的 PM2.5 可能重复数百次 → 自然会多个点堆叠在同一个 X 值。

➡ **不是 bug，是数据特性 + 回归分析散点图的正常表现**

---

## 🔥 2. 为什么线条会打结？

### （1）PM2.5 时间序列波动太剧烈 → predicted 和 actual 频繁交叉

### （2）日期索引不连续（dropna 导致） → Matplotlib 连接错位

### （3）预测本身是 LightGBM 分段函数 → 不平滑

### （4）画的是 300 天的折线 → 峰值多 → 图像出现交错

➡ **不是 bug，而是数据 + 模型本身特性**

---

# ❗ 五、代码优化建议（非常重要）

现在你的模型已经到瓶颈，可以做进一步增强：

---

## ✔ 建议 1：使用更强的目标函数（处理偏态 / 峰值）

PM2.5 是右偏长尾分布 → 建议使用：

### 🔥 对数变换目标：

在训练前：

```python
y_train_log = np.log1p(y_train)
y_val_log = np.log1p(y_val)
y_test_log = np.log1p(y_test)
```

预测后再反变换：

```python
y_pred = np.expm1(y_pred_log)
```

👉 优势：显著提升对峰值（污染爆表时期）的预测能力。

---

## ✔ 建议 2：加入更丰富的特征（最有效）

你当前特征仍然偏弱，可加入：

### (1) **污染物交叉项**

PM2.5 与 NO₂ / SO₂ / O₃ 的化学反应强相关。

```python
df['PM_NO2'] = df['PM2.5'] * df['NO2']
df['PM_SO2'] = df['PM2.5'] * df['SO2']
```

---

### (2) **气象特征组合**

如：

* 湿度 × 风速
* 边界层高度 × 风速
* 温差 × 边界层高度

---

## ✔ 建议 3：做时间序列模型 (LightGBM + lag) 的改进

目前：

```
lag1, lag3, lag7
moving average 3/7/30
```

建议再加入：

* lag2、lag5、lag14（周周期）
* rolling_std(7), rolling_max(7)

---

## ✔ 建议 4：提升模型结构

### （1）用 CatBoost / XGBoost 混合

CatBoost 对长尾噪声鲁棒性很好。

---

### （2）加入线性模型做 stacked ensemble

LightGBM 负责非线性
Ridge 回归负责全局趋势

---

## ✔ 建议 5：绘图优化（防止“打结”）

### 🔥 使用采样绘图：

```python
step = 3
plt.plot(time_idx[::step], y_test[::step], ...)
```

### 🔥 日期不连续 → 按整数 index 绘制：

```python
plt.plot(range(len(y_test)), y_test)
```

---

# 🎯 六、总结

| 问题         | 原因                   | 结论          |
| ---------- | -------------------- | ----------- |
| 同一 X 有多个 Y | 实际值重复导致散点堆叠          | 正常现象        |
| 折线打结       | 波动剧烈 + 日期不连续 + 模型不平滑 | 正常现象、建议平滑处理 |
| 优化效果小      | 特征弱、目标未变换            | 可进一步增强      |

---
